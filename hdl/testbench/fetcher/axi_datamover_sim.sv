// Generated by CIRCT firtool-1.62.0
// external module memory_read

module axi_datamover_sim(
  input          clock,
                 reset,
  input  [95:0]  io_s_axis_mm2s_cmd_tdata,
  input          io_s_axis_mm2s_cmd_tvalid,
  output         io_s_axis_mm2s_cmd_tready,
  output [127:0] io_m_axis_mm2s_tdata,
  output [15:0]  io_m_axis_mm2s_tkeep,
  output         io_m_axis_mm2s_tlast,
                 io_m_axis_mm2s_tvalid,
  input          io_m_axis_mm2s_tready
);

  reg         state;
  reg  [20:0] count;
  reg  [31:0] rdaddr;
  reg  [22:0] btt;
  wire [22:0] _GEN = {2'h0, count};
  always @(posedge clock) begin
    if (reset) begin
      state <= 1'h0;
      count <= 21'h0;
      rdaddr <= 32'h0;
      btt <= 23'h0;
    end
    else begin
      automatic logic _GEN_0;
      automatic logic _GEN_1;
      _GEN_0 = state & io_m_axis_mm2s_tready;
      _GEN_1 = io_s_axis_mm2s_cmd_tvalid & ~state;
      if (state)
        state <= ~(state & _GEN == btt / 23'h10 - 23'h1) & state;
      else
        state <= _GEN_1 | state;
      if (_GEN_0)
        count <= count + 21'h1;
      else if (state) begin
      end
      else
        count <= 21'h0;
      if (state) begin
        if (_GEN_0)
          rdaddr <= rdaddr + 32'h10;
      end
      else if (_GEN_1)
        rdaddr <= io_s_axis_mm2s_cmd_tdata[63:32];
      if (~state & _GEN_1)
        btt <= io_s_axis_mm2s_cmd_tdata[22:0];
    end
  end // always @(posedge)
  memory_read mem (
    .addr (rdaddr),
    .en   (state),
    .data (io_m_axis_mm2s_tdata)
  );
  assign io_s_axis_mm2s_cmd_tready = ~state;
  assign io_m_axis_mm2s_tkeep = 16'hFF;
  assign io_m_axis_mm2s_tlast = _GEN == btt / 23'h10 - 23'h1;
  assign io_m_axis_mm2s_tvalid = state;
endmodule

